/*
        CC v3

 */
const TAG = " | app | "
require('dotenv').config()
require('dotenv').config({path:"../../.env"});
require('dotenv').config({path:"./../../.env"});
require('dotenv').config({path:"../../../.env"});
require('dotenv').config({path:"../../../../.env"});
require('dotenv').config({path:"../../../../.env"});
require('dotenv').config({path:"./../../../../.env"});
require('dotenv').config({path:"./../../../../../.env"});
require('dotenv').config({path:"../../../../../../.env"});

let log = require("@fomobro/loggerdog-client")()
const {redis,subscriber,publisher} = require("@fomobro/default-redis")


const Tokenizer = require('sentence-tokenizer');
const tokenizer = new Tokenizer('reddit');

const rive = require('../nlp/rive.js')
rive.initialize()

// modules
//let request = require('./modules/request.js')
let views = require('../modules/views.js')

//mongo
let connection  = require("@fomobro/mongo-default-env")
let slackOut = connection.get("slackOut");


const defaultChannelName = process.env['SLACK_CHANNEL_FOMO']
const defaultChannelId = process.env['SLACK_CHANNELID_FOMO']
if(!defaultChannelName) throw Error("defaultChannelName not set! ")
if(!defaultChannelId) throw Error("defaultChannelId not set! ")
log.info("Config: ",{defaultChannelName,defaultChannelId})

let params = {
    icon_emoji: ':coincap_v2:',
}


const integrations:any = {}
const urban = require('../modules/urban.js')
integrations['urban'] = urban
const coincapRive = require('../modules/coincap.js')
integrations['coincapRive'] = coincapRive

/***********************************************
 //        onCreate
 //***********************************************/

//subscribe to redis
subscriber.subscribe("slack");
subscriber.subscribe("cli");

subscriber.on("message", async function (channel:any, payloadS:string)
{
    console.log({channel, payloadS})
    var tag = TAG+ " | sub_to_slack | "
    let debug = true
    try{
        log.debug(tag,"payloadS: ",payloadS)
        let payload = JSON.parse(payloadS)
        log.debug(tag,"payload: ",payload)

        let data = payload.data
        let sentence = data.text
        let username = data.user
        let channel = data.channel
        console.log({channel, defaultChannelId})
        if(channel === defaultChannelId){
            //log.debug(tag,"sentence: ",sentence)
            //let resp = await rive.respond(sentence)
            let session = "test"
            let response = await deliberate_on_input(session,data,username)
            if(response){
                log.debug(tag,"response: ",response)
                let message:any = {}
                if(response.view){
                    message.msg = " view generated by API "
                    message.view = response.view
                }else if(response.sentences.length > 0){
                    // create smart view
                    let smartView = await views.smart(response)
                    message.view = smartView.view
                    message.msg = smartView.msg
                }
                //array to view

                //publish response
                message.channel = defaultChannelName

                log.debug(tag,"message: ",message)
                let channel = "publish"
                slackOut.insert(message)
                console.log({message, channel})
                publisher.publish(channel,JSON.stringify(message))
            }

        } else {
            console.log(tag," wrong channel: ",payload.channel," expecting: ",defaultChannelId)
        }


    }catch(e){
        console.error(tag,"Error: ",e)
    }
})


/***********************************************
 //        lib
 //***********************************************/


const deliberate_on_input = async function(session:any,data:any,username:any){
    const tag = " | deliberate_on_input | "
    const debug = true
    const debug1 = false
    try{
        let output:any = {}
        output.sentences = []
        log.debug(tag,"session: ",session)
        log.debug(tag,"data: ",data)
        log.debug(tag,"username: ",username)
        //save context
        //await( redis.sadd(session,data.text))

        //Who am I talking too?
        let userInfo = await redis.hgetall(data.user)

        if(!userInfo) await redis.hmset(data.user,data)
        userInfo = data
        log.debug(tag,"userInfo: ",userInfo)

        //under what context?
        // const context = await redis.smembers(session)
        // if(debug1) console.log(tag,"context: ",context)

        //commands


        //state
        //let state = await( redis.hgetall()

        //change of state

        tokenizer.setEntry(data.text);
        const sentences = tokenizer.getSentences()
        log.debug(tag,"sentences: ",sentences)

        const source = "slack"

        const tokens = tokenizer.getTokens(sentences)
        log.debug(tag,"tokens: ",tokens)


        let state = null
        if(userInfo.state) state = parseInt(userInfo.state)

        switch (state){
            case 1:
                log.info("State 1")
                await redis.hset(data.user,"state",0)

                break
            case 2:
                log.info("State 2 learn")
                // a command was handled and action taken
                output.sentences.push("Ok, lets learn something")
                //save?
                break
            case null:
                log.info("State 3 learn")

                let response2 = await rive.respond(sentences[0])
                if(response2 != "ERR: No Reply Matched"){
                    output.sentences.push(response2)
                }
                //ignore
                break
            default:
                log.info("State 4 learn")
                let response = await rive.respond(sentences[0])
                if(response != "ERR: No Reply Matched"){
                    output.sentences.push(response)
                }
                break
        }




        //
        // //
        //
        // //preprocessing

        //
        // //for each sentence
        // for (let i = 0; i < sentences.length; i++) {
        //     switch (tokens[0]){
        //         case 'help':
        //             // let task = {
        //             //     type:'view',
        //             //     platform:'slack',
        //             //     id:''
        //             // }
        //             //let params = await request.help()
        //             //log.debug(tag,"params: ",params)
        //             output.view = params
        //             output.sentences.push("this is a unhelpfull help message.")
        //             break
        //         case 'refresh':
        //             output.sentences.push(rive.initialize())
        //             break
        //         case "learn":
        //             log.debug(tag,"checkpoint learn: ")
        //             if(tokens[1] === 'commands'){
        //                 //iterate over tokens
        //
        //
        //             }else{
        //                 // a command was handled and action taken
        //                 log.debug(tag,"learn detected! ")
        //                 log.debug(tag,"tokens: ",tokens)
        //                 //MUST have CHAL:  and RESP:
        //                 let chalPlacement = tokens.indexOf("CHAL:")
        //                 let respPlacement = tokens.indexOf("RESP:")
        //                 if(chalPlacement >= 0 && respPlacement >= 0){
        //
        //                     //write RIVE
        //                     //if CMD: assume command
        //                     //is command logical?
        //
        //                     //else string
        //                     //combine tokens
        //                     let chalStart = chalPlacement + 1
        //                     let respStart = respPlacement
        //                     let trigger = ""
        //                     for (let i = chalStart; i < respPlacement; i++) {
        //                         trigger = trigger+" "+tokens[i]
        //                     }
        //
        //                     let response = ""
        //                     for (i = respPlacement + 1; i < tokens.length; i++) {
        //                         if(tokens[i] == "&lt;star&gt;") {
        //                             response = response+" <star>"
        //                         } else {
        //                             response = response+" "+tokens[i]
        //                         }
        //                     }
        //
        //                     let success = await rive.create(trigger,response)
        //                     log.debug(tag,"success: ",success)
        //
        //
        //                     output.sentences.push(success)
        //                 }else {
        //                     //else failed to learn
        //                     //dump how to learn
        //                     output.sentences.push("not a valid lesion asshole! requirements CHAL: AND RESP:")
        //                 }
        //
        //             }
        //
        //
        //
        //
        //
        //             break
        //         case "state":
        //             output.sentences.push("state is "+state)
        //             //ignore
        //             break
        //         default:
        //             const response = await( rive.respond(sentences[i]))
        //             log.debug(tag,"response: ",response)
        //             if(response != "ERR: No Reply Matched"){
        //                 output.sentences.push(response)
        //             }
        //
        //
        //
        //             break
        //     }
        // }
        //
        //

        // //rivescript commands
        for (let i = 0; i < output.sentences.length; i++) {
            log.debug(tag,"output: ",output[i])
            //if contains a CMD: assume command
            log.debug(tag,"sentences: ",output.sentences[i])
            if(output.sentences[i] && output.sentences[i] != true && output.sentences[i].indexOf("CMD:") >= 0){
                //
                log.debug(tag,"split: ",output.sentences[i].split(":"))
                const command = output.sentences[i].split(":")[1]
                log.debug(tag,"command: ",command)

                //
                tokenizer.setEntry(command);
                const commandSentences = tokenizer.getSentences()
                log.debug(tag,"commandSentences: ",commandSentences)
                const commandTokens = tokenizer.getTokens(command)
                log.debug(tag,"commandTokens: ",commandTokens)

                //
                if(username === "U70MM0X9B") username = "pioneer"
                //let result = await request.commands(commandTokens,username)

                let result = " beeboop"

                console.log(tag,"result:", result)

                //const view = create_view_smart(result)
                //console.log(tag,"view:", view)
                output.sentences.push(JSON.stringify(result))

            }
        }
        //
        //
        // if(output.length == 0){
        //     //if unknowns use api's
        //
        // }
        //
        //
        // //remove commands
        for (let i = 0; i < output.sentences.length; i++) {
            if(output.sentences[i] != true && output.sentences[i].indexOf("CMD:") >= 0){
                output.sentences.splice(i, 1);
            }
        }


        return output
    }catch(e){
        console.error(e)
    }
}
